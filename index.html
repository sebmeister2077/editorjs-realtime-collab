<!doctype html>
<html lang="en">
    <head>
        <meta charset="UTF-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <script src="https://cdn.jsdelivr.net/npm/@editorjs/editorjs@2.28.2/dist/editorjs.umd.min.js"></script>
        <script src="https://cdn.jsdelivr.net/npm/@editorjs/header@2.8.1/dist/header.umd.min.js"></script>
        <script src="https://cdn.jsdelivr.net/npm/@editorjs/table@2.3.0/dist/table.umd.js"></script>
        <script src="./dist/bundle.js"></script>
        <script
            src="https://code.jquery.com/jquery-3.7.0.min.js"
            integrity="sha256-2Pmvv0kuTBOenSvLm6bvfBSSHrUJ+3A7x6P5Ebd07/g="
            crossorigin="anonymous"
        ></script>
        <link
            rel="stylesheet"
            href="https://cdn.jsdelivr.net/npm/toastr@2.1.4/build/toastr.min.css"
            integrity="sha256-R91pD48xW+oHbpJYGn5xR0Q7tMhH4xOrWn1QqMRINtA="
            crossorigin="anonymous"
        />
        <!-- <script src="https://unpkg.com/piesocket-js@5"></script> -->
        <script src="https://cdn.jsdelivr.net/npm/toastr@2.1.4/toastr.min.js"></script>
        <script src="https://cdn.jsdelivr.net/npm/@editorjs/paragraph@2.11.7/dist/paragraph.umd.min.js"></script>

        <!-- <script src="https://cdnjs.cloudflare.com/ajax/libs/microsoft-signalr/6.0.1/signalr.js"></script> -->
        <title>EditorJS realtime collab DEMO</title>
        <link rel="stylesheet" href="./index.css" />
    </head>
    <body>
        <div id="holder"></div>

        <div class="throttle">
            <label for="throttleDelay">Block change throttle delay (ms): </label>
            <input type="number" id="throttleDelay" value="300" step="100" min="0" />
            <button id="applyThrottle">Apply</button>
        </div>
        <script type="module">
            import { initializeApp } from 'https://www.gstatic.com/firebasejs/12.7.0/firebase-app.js'
            import { initializeAppCheck, ReCaptchaV3Provider } from 'https://www.gstatic.com/firebasejs/12.7.0/firebase-app-check.js'
            import {
                getAuth,
                signInAnonymously,
                onAuthStateChanged,
                inMemoryPersistence,
                browserSessionPersistence,
            } from 'https://www.gstatic.com/firebasejs/12.7.0/firebase-auth.js'
            import {
                getDatabase,
                ref,
                set,
                onValue,
                get,
                push,
                onChildAdded,
                orderByChild,
                query,
                startAt,
                endAt,
                onDisconnect,
            } from 'https://www.gstatic.com/firebasejs/12.7.0/firebase-database.js'
            import { getAnalytics } from 'https://www.gstatic.com/firebasejs/12.7.0/firebase-analytics.js'
            const dataLocation = 'editorJs-default-data-realtime'
            const defaultBlocks = [
                {
                    id: 'firstid',
                    type: 'paragraph',
                    data: {
                        text: 'This is some default text',
                    },
                },
                {
                    id: 'secondid',
                    type: 'paragraph',
                    data: {
                        text: 'This is some other text',
                    },
                },
            ]
            const sessionData = sessionStorage.getItem(dataLocation)
            let throttleTimeoutValue = Number(document.getElementById('throttleDelay').value) ?? 300

            ;(async () => {
                const {
                    default: { something_you_cant_find_with_grep, ...firebaseConfig },
                } = await import('./config.json', { with: { type: 'json' } })

                const app = initializeApp(firebaseConfig)
                const appCheck = initializeAppCheck(app, {
                    provider: new ReCaptchaV3Provider(something_you_cant_find_with_grep),
                    isTokenAutoRefreshEnabled: true,
                })
                const auth = getAuth(app)
                auth.setPersistence(browserSessionPersistence)
                let user = null
                let isInitial = true
                const authPromise = new Promise((resolve) => {
                    const unsubscribe = onAuthStateChanged(auth, (u) => {
                        user = u
                        if (!user && isInitial) {
                            isInitial = false
                            return
                        }
                        resolve()
                        unsubscribe()
                    })
                })
                try {
                    await signInAnonymously(auth)
                    await authPromise
                    console.log('Signed in anonymously as user', user.uid)
                } catch (err) {
                    const errorCode = error.code
                    const errorMessage = error.message
                    console.error('Error signing in anonymously', errorCode, errorMessage)
                }
                const analytics = getAnalytics(app)

                let lastSeenMessageTimestamp = Date.now()
                const subscribers = new Map()
                const userId = user ? user.uid : crypto.randomUUID()
                const db = getDatabase(app)
                // cleanupOldMessages(db)

                const envPrefix = window.location.hostname === 'localhost' || window.location.hostname === '127.0.0.1' ? 'dev/' : 'prod/'
                const messagesAddRef = ref(db, envPrefix + 'messages')
                const messagesRef = query(ref(db, envPrefix + 'messages'), orderByChild('timestamp'), startAt(lastSeenMessageTimestamp + 1))
                const presenceRef = ref(db, `${envPrefix}presence/${userId}`)
                const usersPrecenseRef = query(
                    ref(db, envPrefix + 'presence'),
                    orderByChild('lastSeen'),
                    startAt(Date.now() - 1000 * 60 * 1),
                ) // last 1 minutes
                onDisconnect(presenceRef).remove()
                set(presenceRef, { lastSeen: Date.now() })
                setInterval(() => {
                    set(presenceRef, { lastSeen: Date.now() })
                }, 1000 * 30) // every 30 seconds

                const connectedRef = ref(db, '.info/connected')
                let hasEverDisconnected = false
                onValue(connectedRef, (snap) => {
                    if (snap.val() === true) {
                        if (hasEverDisconnected) toastr.info('Connected to socket')
                    } else {
                        if (hasEverDisconnected) toastr.info('Disconnected from socket')
                        hasEverDisconnected = true
                    }
                })
                let onlineUsers = []
                onValue(usersPrecenseRef, (snapshot) => {
                    const newOnlineUsers = []
                    snapshot.forEach((childSnapshot) => {
                        newOnlineUsers.push(childSnapshot.key)
                    })
                    if (newOnlineUsers.length === onlineUsers.length) return
                    onlineUsers = newOnlineUsers
                    toastr.info('Online users:' + onlineUsers.length)
                })
                const socket = {
                    on: (name, cb) => {
                        const subscriber = onChildAdded(messagesRef, (snapshot) => {
                            const msg = snapshot.val()

                            if (msg.senderId === userId) return // ignore own messages
                            if (msg.eventName !== name) return // ignore other events for this listener

                            const deserializedPayload = deserializeArrays(msg.payload)
                            cb(deserializedPayload)
                        })
                        const existingSubscribers = subscribers.get(name) || []
                        existingSubscribers.push(subscriber)
                        subscribers.set(name, existingSubscribers)
                    },
                    send: (name, data = null) => {
                        const serializedData = serializeArrays(data)
                        const dbMessage = {
                            senderId: userId,
                            timestamp: Date.now(),
                            eventName: name,
                            payload: serializedData,
                        }
                        push(messagesAddRef, dbMessage).catch((error) => {
                            console.log('Error sending message', error, dbMessage)
                        })
                    },
                    off: (name) => {
                        const existingSubscribers = subscribers.get(name) || []
                        existingSubscribers.forEach((unsubscribe) => {
                            unsubscribe() // Detach the listener
                        })
                        subscribers.delete(name)
                    },
                }

                // console.log('socket subscribed')

                let timeout = null

                const isOpera = navigator.userAgentData.brands.some((brand) => brand.brand.toLowerCase().includes('opera'))
                const askTimeout = isOpera ? 500 : 2000
                toastr.options = {
                    progressBar: true,
                    preventDuplicates: true,
                    timeout: askTimeout - 300,
                }
                toastr.info('Receiving data from online users...')

                const askEvent = 'ask-for-all-data'
                const receiveEvent = 'receive-all-data'

                let isEditorInstantiated = false
                socket.on(receiveEvent, (res) => {
                    if (timeout) clearTimeout(timeout)
                    throttleTimeoutValue = res.throttleTimeout ?? 300
                    initEditorWithOrWithoutData(res.data)
                })

                setTimeout(() => {
                    socket.send(askEvent)
                }, 200)

                timeout = setTimeout(initEditorWithOrWithoutData, askTimeout)
                async function initEditorWithOrWithoutData(otherUserData) {
                    if (isEditorInstantiated) return
                    isEditorInstantiated = true
                    toastr.clear()
                    toastr.options = {
                        preventDuplicates: true,
                    }
                    if (!otherUserData) {
                        // toastr.warning('No more online users')
                        toastr.success('Using default data')
                    } else {
                        toastr.success('Received data')
                    }
                    const editor = new EditorJS({
                        data:
                            otherUserData ??
                            (sessionData
                                ? JSON.parse(sessionData)
                                : {
                                      time: Date.now(),
                                      blocks: defaultBlocks,
                                      version: '2.28.2',
                                  }),
                        holder: 'holder',
                        tools: {
                            header: Header,
                            table: Table,
                            paragraph: {
                                class: self.Paragraph,
                                config: {
                                    preserveBlank: true,
                                },
                            },
                        },
                        onChange(api) {
                            api.saver.save().then((data) => {
                                if (data) {
                                    sessionStorage.setItem(dataLocation, JSON.stringify(data))
                                }
                            })
                        },
                    })

                    await editor.isReady
                    //sync editor with other online users
                    socket.on(askEvent, () => {
                        toastr.info('saving and sharing data to newly connected user')
                        editor.save().then((data) => {
                            socket.send(receiveEvent, { data, throttleTimeoutValue })
                        })
                    })

                    let groupCollab = setupPlugin()

                    groupCollab.listen()
                    document.getElementById('applyThrottle').addEventListener('click', (event) => {
                        const newValue = Number(document.getElementById('throttleDelay').value)
                        if (newValue == throttleTimeoutValue) return
                        throttleTimeoutValue = newValue

                        groupCollab.unlisten()

                        socket.send('throttle-timeout-change', { newTimeout: throttleTimeoutValue })
                        groupCollab = setupPlugin()

                        groupCollab.listen()
                    })

                    socket.on('throttle-timeout-change', (data) => {
                        const newTimeout = data.newTimeout
                        if (newTimeout == throttleTimeoutValue || typeof throttleTimeoutValue !== 'number') return
                        throttleTimeoutValue = newTimeout

                        groupCollab.unlisten()

                        toastr.info(`Throttle timeout changed to ${throttleTimeoutValue}ms by another user`)
                        document.getElementById('throttleDelay').value = String(throttleTimeoutValue)
                        groupCollab = setupPlugin()

                        groupCollab.listen()
                    })

                    function setupPlugin() {
                        const colors = ['red', 'green', 'blue', 'orange', 'purple', 'cyan', 'magenta', 'lime', 'teal', 'pink']
                        const colorIndex = Math.floor(Math.random() * colors.length)
                        console.log('Assigned cursor color:', colors[colorIndex])
                        return new RealtimeCollabPlugin({
                            editor,
                            socket: {
                                send: socket.send,
                                on: socket.on,
                                off: socket.off,
                                connectionId: userId,
                            },
                            blockChangeThrottleDelay: throttleTimeoutValue,
                            cursor: { color: colors[colorIndex], selectionColor: colors[colorIndex] },
                        })
                    }
                }
            })()

            // for compatibility with the document based lists
            // when list is empty, it is not saved at all, so we need to serialize arrays manually
            const ARRAY_MARKER = '__type'
            const ARRAY_TYPE = 'array'
            function serializeArrays(value) {
                if (Array.isArray(value)) {
                    const items = {}

                    value.forEach((item, index) => {
                        items[index] = serializeArrays(item)
                    })

                    return {
                        [ARRAY_MARKER]: ARRAY_TYPE,
                        items,
                    }
                }

                if (value !== null && typeof value === 'object') {
                    const result = {}
                    for (const key in value) {
                        result[key] = serializeArrays(value[key])
                    }
                    return result
                }

                // primitives
                return value
            }

            function deserializeArrays(value) {
                if (value && typeof value === 'object' && value[ARRAY_MARKER] === ARRAY_TYPE && value.items) {
                    const array = []

                    Object.keys(value.items)
                        .sort((a, b) => Number(a) - Number(b))
                        .forEach((key) => {
                            array[Number(key)] = deserializeArrays(value.items[key])
                        })

                    return array
                }

                if (value !== null && typeof value === 'object') {
                    const result = {}
                    for (const key in value) {
                        result[key] = deserializeArrays(value[key])
                    }
                    return result
                }

                return value
            }

            function cleanupOldMessages(db) {
                const cutoff = Date.now() - 1000 * 60 * 60 * 24 // 1 day ago
                const oldMessagesQuery = query(ref(db, envPrefix + 'messages'), orderByChild('timestamp'), endAt(cutoff))
                const listener = onValue(oldMessagesQuery, (snapshot) => {
                    listener()
                    console.log('Cleaning up old messages...')
                    console.log(snapshot.size + ' old messages found')
                    snapshot.forEach((childSnapshot) => {
                        console.log(childSnapshot)
                        set(childSnapshot.ref, null)
                        // childSnapshot.ref.remove()
                    })
                })
            }
        </script>
    </body>
</html>
